.\" Automatically generated by Pod::Man 2.16 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "BibTeX::Value 3"
.TH BibTeX::Value 3 "2009-10-31" "perl v5.8.7" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Text::BibTeX::Value \- interfaces to BibTeX values and simple values
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use Text::BibTeX;
\&
\&   $entry = new Text::BibTeX::Entry;
\&
\&   # set the \*(Aqpreserve_values\*(Aq flag to 1 for this parse
\&   $entry\->parse ($filename, $filehandle, 1);
\&
\&   # \*(Aqget\*(Aq method now returns a Text::BibTeX::Value object 
\&   # rather than a string
\&   $value = $entry\->get ($field);
\&
\&   # query the \`Value\*(Aq object (list of SimpleValue objects)
\&   @all_values = $value\->values;
\&   $first_value = $value\->value (0);
\&   $last_value = $value\->value (\-1);
\&
\&   # query the simple value objects \-\- type will be one of BTAST_STRING,
\&   # BTAST_MACRO, or BTAST_NUMBER
\&   use Text::BibTex (\*(Aq:nodetypes\*(Aq);   # import "node type" constants
\&   $is_macro = ($first_value\->type == BTAST_MACRO);
\&   $text = $first_value\->text;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`Text::BibTeX::Value\*(C'\fR module provides two classes,
\&\f(CW\*(C`Text::BibTeX::Value\*(C'\fR and \f(CW\*(C`Text::BibTeX::SimpleValue\*(C'\fR, which respectively
give you access to BibTeX \*(L"compound values\*(R" and \*(L"simple values\*(R".  Recall
that every field value in a BibTeX entry is the concatenation of one or
more simple values, and that each of those simple values may be a literal
string, a macro (abbreviation), or a number.  Normally with
\&\f(CW\*(C`Text::BibTeX\*(C'\fR, field values are \*(L"fully processed,\*(R" so that you only have
access to the string that results from expanding macros, converting numbers
to strings, concatenating all sub-strings, and collapsing whitespace in the
resulting string.
.PP
For example, in the following entry:
.PP
.Vb 6
\&   @article{homer97,
\&     author = "Homer Simpson" # and # "Ned Flanders",
\&     title = {Territorial Imperatives in Modern Suburbia},
\&     journal = jss,
\&     year = 1997
\&   }
.Ve
.PP
we see the full range of options.  The \f(CW\*(C`author\*(C'\fR field consists of three
simple values: a string, a macro (\f(CW\*(C`and\*(C'\fR), and another string.  The
\&\f(CW\*(C`title\*(C'\fR field is a single string, and the \f(CW\*(C`journal\*(C'\fR and \f(CW\*(C`year\*(C'\fR fields
are, respectively, a single macro and a single number.  If you parse
this entry in the usual way:
.PP
.Vb 1
\&   $entry = new Text::BibTeX::Entry $entry_text;
.Ve
.PP
then the \f(CW\*(C`get\*(C'\fR method on \f(CW$entry\fR would return simple strings.
Assuming that the \f(CW\*(C`and\*(C'\fR macro is defined as \f(CW" and "\fR, then
.PP
.Vb 1
\&   $entry\->get (\*(Aqauthor\*(Aq)
.Ve
.PP
would return the Perl string \f(CW"Homer Simpson and Ned Flanders"\fR.
.PP
However, you can also request that the library preserve the input values
in your entries, i.e. not lose the information about which values use
macros, which values are composed of multiple simple values, and so on.
There are two ways to make this request: per-file and per-entry.  For a
per-file request, use the \f(CW\*(C`preserve_values\*(C'\fR method on your \f(CW\*(C`File\*(C'\fR
object:
.PP
.Vb 2
\&   $bibfile = new Text::BibTeX::File $filename;
\&   $bibfile\->preserve_values (1);
\&
\&   $entry = new Text::BibTeX::Entry $bibfile;
\&   $entry\->get ($field);        # returns a Value object
\&
\&   $bibfile\->preserve_values (0);
\&   $entry = new Text::BibTeX::Entry $bibfile;
\&   $entry\->get ($field);        # returns a string
.Ve
.PP
If you're not using a \f(CW\*(C`File\*(C'\fR object, or want to control things at a
finer scale, then you have to pass in the \f(CW\*(C`preserve_values\*(C'\fR flag when
invoking \f(CW\*(C`read\*(C'\fR, \f(CW\*(C`parse\*(C'\fR, or \f(CW\*(C`parse_s\*(C'\fR on your \f(CW\*(C`Entry\*(C'\fR objects:
.PP
.Vb 4
\&   # no File object, parsing from a string
\&   $entry = new Text::BibTeX::Entry;
\&   $entry\->parse_s ($entry_text, 0);  # preserve_values=0 (default)
\&   $entry\->get ($field);        # returns a string
\&
\&   $entry\->parse_s ($entry_text, 1);
\&   $entry\->get ($field);        # returns a Value object
\&
\&   # using a File object, but want finer control
\&   $entry\->read ($bibfile, 0);  # now get will return strings (default)
\&   $entry\->read ($bibfile, 1);  # now get will return Value objects
.Ve
.PP
A compound value, usually just called a value, is simply a list of
simple values.  The \f(CW\*(C`Text::BibTeX::Value\*(C'\fR class (hereinafter
abbreviated as \f(CW\*(C`Value\*(C'\fR) provides a simple interface to this list; you
can request the whole list, or an individual member of the list.  The
\&\f(CW\*(C`SimpleValue\*(C'\fR class gives you access to the innards of each simple
value, which consist of the \fItype\fR and the \fItext\fR.  The type just
tells you if this simple value is a string, macro, or number; it is
represented using the Perl translation of the \*(L"node type\*(R" enumeration
from C.  The possible types are \f(CW\*(C`BTAST_STRING\*(C'\fR, \f(CW\*(C`BTAST_NUMBER\*(C'\fR, and
\&\f(CW\*(C`BTAST_MACRO\*(C'\fR.  The text is just what appears in the original entry
text, be it a string, number, or macro.
.PP
For example, we could parse the above entry in \*(L"preserve values\*(R" mode as
follows:
.PP
.Vb 1
\&   $entry\->parse_s ($entry_text, 1);   # preserve_values is 1
.Ve
.PP
Then, using the \f(CW\*(C`get\*(C'\fR method on \f(CW$entry\fR would return not a string,
but a \f(CW\*(C`Value\*(C'\fR object.  We can get the list of all simple values using
the \f(CW\*(C`values\*(C'\fR method, or a single value using \f(CW\*(C`value\*(C'\fR:
.PP
.Vb 3
\&   $author = $entry\->get (\*(Aqauthor\*(Aq);   # now a Text::BibTeX::Value object
\&   @all_values = $author\->values;      # array of Text::BibTeX::SimpleValue
\&   $second = $author\->value (1);       # same as $all_values[1]
.Ve
.PP
The simple values may be queried using the \f(CW\*(C`Text::BibTeX::SimpleValue\*(C'\fR
methods, \f(CW\*(C`type\*(C'\fR and \f(CW\*(C`text\*(C'\fR:
.PP
.Vb 2
\&   $all_values[0]\->type;               # returns BTAST_STRING
\&   $second\->type;                      # returns BTAST_MACRO
\&
\&   $all_values[0]\->text;               # "Homer Simpson"
\&   $second\->text;                      # "and" (NOT the macro expansion!)
\&
\&   $entry\->get (\*(Aqyear\*(Aq)\->value (0)\->text;   # "1997"
.Ve
.SH "METHODS"
.IX Header "METHODS"
Normally, you won't need to create \f(CW\*(C`Value\*(C'\fR or \f(CW\*(C`SimpleValue\*(C'\fR
objects\-\-\-they'll be created for you when an entry is parsed, and
returned to you by the \f(CW\*(C`get\*(C'\fR method in the \f(CW\*(C`Entry\*(C'\fR class.  Thus, the
query methods (\f(CW\*(C`values\*(C'\fR and \f(CW\*(C`value\*(C'\fR for the \f(CW\*(C`Value\*(C'\fR class, \f(CW\*(C`type\*(C'\fR
and \f(CW\*(C`text\*(C'\fR for \f(CW\*(C`SimpleValue\*(C'\fR) are probably all you need to worry
about.  If you wish, though, you can create new values and simple values
using the two classes' respective constructors.  You can also put
newly-created \f(CW\*(C`Value\*(C'\fR objects back into an existing \f(CW\*(C`Entry\*(C'\fR object
using the \f(CW\*(C`set\*(C'\fR entry method; it doesn't matter how the entry was
parsed, this is acceptable anytime.
.Sh "Text::BibTeX::Value methods"
.IX Subsection "Text::BibTeX::Value methods"
.IP "new (\s-1SVAL\s0, ...)" 4
.IX Item "new (SVAL, ...)"
Creates a new \f(CW\*(C`Value\*(C'\fR object from a list of simple values.  Each simple
value, \s-1SVAL\s0, may be either a \f(CW\*(C`SimpleValue\*(C'\fR object or a reference to a
two-element list containing the type and text of the simple value.  For
example, one way to recreate the \f(CW\*(C`author\*(C'\fR field of the example entry in
\&\*(L"\s-1DESCRIPTION\s0\*(R" would be:
.Sp
.Vb 5
\&   $and_macro = new Text::BibTeX::SimpleValue (BTAST_MACRO, \*(Aqand\*(Aq);
\&   $value = new Text::BibTeX::Value 
\&      ([BTAST_STRING, \*(AqHomer Simpson\*(Aq],
\&       $and_macro,
\&       [BTAST_STRING, \*(AqNed Flanders\*(Aq]);
.Ve
.Sp
The resulting \f(CW\*(C`Value\*(C'\fR object could then be installed into an entry
using the \f(CW\*(C`set\*(C'\fR method of the \f(CW\*(C`Entry\*(C'\fR class.
.IP "values ()" 4
.IX Item "values ()"
Returns the list of \f(CW\*(C`SimpleValue\*(C'\fR objects that make up a \f(CW\*(C`Value\*(C'\fR object.
.IP "value (\s-1NUM\s0)" 4
.IX Item "value (NUM)"
Returns the \s-1NUM\s0'th \f(CW\*(C`SimpleValue\*(C'\fR object from the list of \f(CW\*(C`SimpleValue\*(C'\fR
objects that make up a \f(CW\*(C`Value\*(C'\fR object.  This is just like a Perl array
reference: \s-1NUM\s0 is zero-based, and negative numbers count from the end of
the array.
.Sh "Text::BibTeX::SimpleValue methods"
.IX Subsection "Text::BibTeX::SimpleValue methods"
.IP "new (\s-1TYPE\s0, \s-1TEXT\s0)" 4
.IX Item "new (TYPE, TEXT)"
Creates a new \f(CW\*(C`SimpleValue\*(C'\fR object with the specified \s-1TYPE\s0 and \s-1TEXT\s0.
\&\s-1TYPE\s0 must be one of the allowed types for BibTeX simple values,
i.e. \f(CW\*(C`BTAST_STRING\*(C'\fR, \f(CW\*(C`BTAST_NUMBER\*(C'\fR, or \f(CW\*(C`BTAST_MACRO\*(C'\fR.  You'll
probably want to import these constants from \f(CW\*(C`Text::BibTeX\*(C'\fR using the
\&\f(CW\*(C`nodetypes\*(C'\fR export tag:
.Sp
.Vb 1
\&   use Text::BibTeX qw(:nodetypes);
.Ve
.Sp
\&\s-1TEXT\s0 may be any string.  Note that if \s-1TYPE\s0 is \f(CW\*(C`BTAST_NUMBER\*(C'\fR and \s-1TEXT\s0
is not a string of digits, the \f(CW\*(C`SimpleValue\*(C'\fR object will be created
anyways, but a warning will be issued.  No warning is issued about
non-existent macros.
.IP "type ()" 4
.IX Item "type ()"
Returns the type of a simple value.  This will be one of the allowed
\&\*(L"node types\*(R" as described under \*(L"new\*(R" above.
.IP "text ()" 4
.IX Item "text ()"
Returns the text of a simple value.  This is just the text that appears
in the original entry\-\-\-unexpanded macro name, or unconverted number.
(Of course, converting numbers doesn't make any difference from Perl; in
fact, it's all the same in C too, since the C code just keeps numbers as
strings of digits.  It's simply a matter of whether the string of digits
is represented as a string or a number, which you might be interested in
knowing if you want to preserve the structure of the input as much
possible.)
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Text::BibTeX, Text::BibTeX::File, Text::BibTeX::Entry
.SH "AUTHOR"
.IX Header "AUTHOR"
Greg Ward <gward@python.net>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 1997\-2000 by Gregory P. Ward.  All rights reserved.  This file
is part of the Text::BibTeX library.  This library is free software; you
may redistribute it and/or modify it under the same terms as Perl itself.
