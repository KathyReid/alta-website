.\" Automatically generated by Pod::Man 2.16 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "BibTeX::Structure 3"
.TH BibTeX::Structure 3 "2009-10-31" "perl v5.8.7" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Text::BibTeX::Structure \- provides base classes for user structure modules
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&   # Define a \*(AqFoo\*(Aq structure for BibTeX databases: first, the
\&   # structure class:
\&
\&   package Text::BibTeX::FooStructure;
\&   @ISA = (\*(AqText::BibTeX::Structure\*(Aq);
\&
\&   sub known_option 
\&   {
\&      my ($self, $option) = @_;
\&
\&      ...
\&   }
\&
\&   sub default_option
\&   {
\&      my ($self, $option) = @_;
\&
\&      ...
\&   }
\&
\&   sub describe_entry
\&   {
\&      my $self = shift;
\&
\&      $self\->set_fields ($type,
\&                         \e@required_fields,
\&                         \e@optional_fields,
\&                         [$constraint_1, $constraint_2, ...]);
\&      ...
\&   }
\&
\&
\&   # Now, the structured entry class
\&
\&   package Text::BibTeX::FooEntry;
\&   @ISA = (\*(AqText::BibTeX::StructuredEntry\*(Aq);
\&
\&   # define whatever methods you like
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The module \f(CW\*(C`Text::BibTeX::Structure\*(C'\fR provides two classes that form the
basis of the \fBbtOOL\fR \*(L"structure module\*(R" system.  This system is how
database structures are defined and imposed on BibTeX files, and
provides an elegant synthesis of object-oriented techniques with
BibTeX-style database structures.  Nothing described here is
particularly deep or subtle; anyone familar with object-oriented
programming should be able to follow it.  However, a fair bit of jargon
in invented and tossed around, so pay attention.
.PP
A \fIdatabase structure\fR, in \fBbtOOL\fR parlance, is just a set of allowed
entry types and the rules for fields in each of those entry types.
Currently, there are three kinds of rules that apply to fields: some
fields are \fIrequired\fR, meaning they must be present in every entry for
a given type; some are \fIoptional\fR, meaning they may be present, and
will be used if they are; other fields are members of \fIconstraint
sets\fR, which are explained in \*(L"Field lists and constraint sets\*(R"
below.
.PP
A \fBbtOOL\fR structure is implemented with two classes: the \fIstructure
class\fR and the \fIstructured entry class\fR.  The former defines everything
that applies to the structure as a whole (allowed types and field
rules).  The latter provides methods that operate on individual entries
which conform (or are supposed to conform) to the structure.  The two
classes provided by the \f(CW\*(C`Text::BibTeX::Structure\*(C'\fR module are
\&\f(CW\*(C`Text::BibTeX::Structure\*(C'\fR and \f(CW\*(C`Text::BibTeX::StructuredEntry\*(C'\fR; these
serve as base classes for, respectively, all structure classes and all
structured entry classes.  One canonical structure is provided as an
example with \fBbtOOL\fR: the \f(CW\*(C`Bib\*(C'\fR structure, which (via the
\&\f(CW\*(C`BibStructure\*(C'\fR and \f(CW\*(C`BibEntry\*(C'\fR classes) provides the same functionality
as the standard style files of BibTeX 0.99.  It is hoped that other
programmers will write new bibliography-related structures, possibly
deriving from the \f(CW\*(C`Bib\*(C'\fR structure, to emulate some of the functionality
that is available through third-party BibTeX style files.
.PP
The purpose of this manual page is to describe the whole \*(L"structure
module\*(R" system.  It is mainly for programmers wishing to implement a new
database structure for data files with BibTeX syntax; if you are
interested in the particular rules for the BibTeX-emulating \f(CW\*(C`Bib\*(C'\fR
structure, see Text::BibTeX::Bib.
.PP
Please note that the \f(CW\*(C`Text::BibTeX\*(C'\fR prefix is dropped from most module
and class names in this manual page, except where necessary.
.SH "STRUCTURE CLASSES"
.IX Header "STRUCTURE CLASSES"
Structure classes have two roles: to define the list of allowed types
and field rules, and to handle \fIstructure options\fR.
.Sh "Field lists and constraint sets"
.IX Subsection "Field lists and constraint sets"
Field lists and constraint sets define the database structure for a
particular entry type: that is, they specify the rules which an entry
must follow to conform to the structure (assuming that entry is of an
allowed type).  There are three components to the field rules for each
entry type: a list of required fields, a list of optional fields, and
\&\fIfield constraints\fR.  Required and optional fields should be obvious to
anyone with BibTeX experience: all required fields must be present, and
any optional fields that are present have some meaning to the structure.
(One could conceive of a \*(L"strict\*(R" interpretation, where any field not
mentioned in the official definition is disallowed; this would be
contrary to the open spirit of BibTeX databases, but could be useful in
certain applications where a stricter level of control is desired.
Currently, \fBbtOOL\fR does not offer such an option.)
.PP
Field constraints capture the \*(L"one or the other, but not both\*(R" type of
relationships present for some entry types in the BibTeX standard style
files.  Most BibTeX documentation glosses over the distinction between
mutually constrained fields and required/optional fields.  For instance,
one of the standard entry types is \f(CW\*(C`book\*(C'\fR, and "\f(CW\*(C`author\*(C'\fR or \f(CW\*(C`editor\*(C'\fR"
is given in the list of required fields for that type.  The meaning of
this is that an entry of type \f(CW\*(C`book\*(C'\fR must have \fIeither\fR the \f(CW\*(C`author\*(C'\fR
or \f(CW\*(C`editor\*(C'\fR fields, but not both.  Likewise, the "\f(CW\*(C`volume\*(C'\fR or
\&\f(CW\*(C`number\*(C'\fR\*(L" are listed under the \*(R"optional fields" heading for \f(CW\*(C`book\*(C'\fR
entries; it would be more accurate to say that every \f(CW\*(C`book\*(C'\fR entry may
have one or the other, or neither, of \f(CW\*(C`volume\*(C'\fR or \f(CW\*(C`number\*(C'\fR\-\-\-but not
both.
.PP
\&\fBbtOOL\fR attempts to clarify this situation by creating a third category
of fields, those that are mutually constrained.  For instance, neither
\&\f(CW\*(C`author\*(C'\fR nor \f(CW\*(C`editor\*(C'\fR appears in the list of required fields for
the \f(CW\*(C`inbook\*(C'\fR type according to \fBbtOOL\fR; rather, a field constraint is
created to express this relationship:
.PP
.Vb 1
\&   [1, 1, [\*(Aqauthor\*(Aq, \*(Aqeditor\*(Aq]]
.Ve
.PP
That is, a field constraint is a reference to a three-element list.  The
last element is a reference to the \fIconstraint set\fR, the list of fields
to which the constraint applies.  (Calling this a set is a bit
inaccurate, as there are conditions in which the order of fields
matters\-\-\-see the \f(CW\*(C`check_field_constraints\*(C'\fR method in \*(L"\s-1METHODS\s0 2:
\&\s-1BASE\s0 \s-1STRUCTURED\s0 \s-1ENTRY\s0 \s-1CLASS\s0\*(R".)  The first two elements are the minimum
and maximum number of fields from the constraint set that must be
present for an entry to conform to the constraint.  This constraint thus
expresses that there must be exactly one (>= 1 and <= 1) of the fields
\&\f(CW\*(C`author\*(C'\fR and \f(CW\*(C`editor\*(C'\fR in a \f(CW\*(C`book\*(C'\fR entry.
.PP
The \*(L"either one or neither, but not both\*(R" constraint that applies to the
\&\f(CW\*(C`volume\*(C'\fR and \f(CW\*(C`number\*(C'\fR fields for \f(CW\*(C`book\*(C'\fR entries is expressed slightly
differently:
.PP
.Vb 1
\&   [0, 1, [\*(Aqvolume\*(Aq, \*(Aqnumber\*(Aq]]
.Ve
.PP
That is, either 0 or 1, but not the full 2, of \f(CW\*(C`volume\*(C'\fR and \f(CW\*(C`number\*(C'\fR
may be present.
.PP
It is important to note that checking and enforcing field constraints is
based purely on counting which fields from a set are actually present;
this mechanism can't capture \*(L"x must be present if y is\*(R" relationships.
.PP
The requirements imposed on the actual structure class are simple: it
must provide a method \f(CW\*(C`describe_entry\*(C'\fR which sets up a fancy data
structure describing the allowed entry types and all the field rules for
those types.  The \f(CW\*(C`Structure\*(C'\fR class provides methods (inherited by a
particular structure class) to help particular structure classes create
this data structure in a consistent, controlled way.  For instance, the
\&\f(CW\*(C`describe_structure\*(C'\fR method in the BibTeX 0.99\-emulating
\&\f(CW\*(C`BibStructure\*(C'\fR class is quite simple:
.PP
.Vb 3
\&   sub describe_entry
\&   {
\&      my $self = shift;
\&
\&      # series of 13 calls to $self\->set_fields (one for each standard
\&      # entry type)
\&   }
.Ve
.PP
One of those calls to the \f(CW\*(C`set_fields\*(C'\fR method defines the rules for
\&\f(CW\*(C`book\*(C'\fR entries:
.PP
.Vb 5
\&   $self\->set_fields (\*(Aqbook\*(Aq,
\&                      [qw(title publisher year)],  
\&                      [qw(series address edition month note)],
\&                      [1, 1, [qw(author editor)]],
\&                      [0, 1, [qw(volume number)]]);
.Ve
.PP
The first field list is the list of required fields, and the second is
the list of optional fields.  Any number of field constraints may follow
the list of optional fields; in this case, there are two, one for each
of the constraints (\f(CW\*(C`author\*(C'\fR/\f(CW\*(C`editor\*(C'\fR and \f(CW\*(C`volume\*(C'\fR/\f(CW\*(C`number\*(C'\fR)
described above.  At no point is a list of allowed types explicitly
supplied; rather, each call to \f(CW\*(C`set_fields\*(C'\fR adds one more allowed type.
.PP
New structure modules that derive from existing ones will probably use the
\&\f(CW\*(C`add_fields\*(C'\fR method (and possibly \f(CW\*(C`add_constraints\*(C'\fR) to augment an
existing entry type.  Adding new types should be done with \f(CW\*(C`set_fields\*(C'\fR,
though.
.Sh "Structure options"
.IX Subsection "Structure options"
The other responsibility of structure classes is to handle \fIstructure
options\fR.  These are scalar values that let the user customize the
behaviour of both the structure class and the structured entry class.
For instance, one could have an option to enable \*(L"extended structure\*(R",
which might add on a bunch of new entry types and new fields.  (In this
case, the \f(CW\*(C`describe_entry\*(C'\fR method would have to pay attention to this
option and modify its behaviour accordingly.)  Or, one could have
options to control how the structured entry class sorts or formats
entries (for bibliography structures such as \f(CW\*(C`Bib\*(C'\fR).
.PP
The easy way to handle structure options is to provide two methods,
\&\f(CW\*(C`known_option\*(C'\fR and \f(CW\*(C`default_option\*(C'\fR.  These return, respectively,
whether a given option is supported, and what its default value is.  (If
your structure doesn't support any options, you can just inherit these
methods from the \f(CW\*(C`Structure\*(C'\fR class.  The default \f(CW\*(C`known_option\*(C'\fR
returns false for all options, and its companion \f(CW\*(C`default_option\*(C'\fR
crashes with an \*(L"unknown option\*(R" error.)
.PP
Once \f(CW\*(C`known_option\*(C'\fR and \f(CW\*(C`default_option\*(C'\fR are provided, the structure
class can sit back and inherit the more visible \f(CW\*(C`set_options\*(C'\fR and
\&\f(CW\*(C`get_options\*(C'\fR methods from the \f(CW\*(C`Structure\*(C'\fR class.  These are the
methods actually used to modify/query options, and will be used by
application programs to customize the structure module's behaviour, and
by the structure module itself to pay attention to the user's wishes.
.PP
Options should generally have pure string values, so that the generic
set_options method doesn't have to parse user-supplied strings into some
complicated structure.  However, \f(CW\*(C`set_options\*(C'\fR will take any scalar
value, so if the structure module clearly documents its requirements,
the application program could supply a structure that meets its needs.
Keep in mind that this requires cooperation between the application and
the structure module; the intermediary code in
\&\f(CW\*(C`Text::BibTeX::Structure\*(C'\fR knows nothing about the format or syntax of
your structure's options, and whatever scalar the application passes via
\&\f(CW\*(C`set_options\*(C'\fR will be stored for your module to retrieve via
\&\f(CW\*(C`get_options\*(C'\fR.
.PP
As an example, the \f(CW\*(C`Bib\*(C'\fR structure supports a number of \*(L"markup\*(R"
options that allow applications to control the markup language used for
formatting bibliographic entries.  These options are naturally paired,
as formatting commands in markup languages generally have to be turned
on and off.  The \f(CW\*(C`Bib\*(C'\fR structure thus expects references to two-element
lists for markup options; to specify LaTeX 2e\-style emphasis for book
titles, an application such as \f(CW\*(C`btformat\*(C'\fR would set the \f(CW\*(C`btitle_mkup\*(C'\fR
option as follows:
.PP
.Vb 1
\&   $structure\->set_options (btitle_mkup => [\*(Aq\eemph{\*(Aq, \*(Aq}\*(Aq]);
.Ve
.PP
Other options for other structures might have a more complicated
structure, but it's up to the structure class to document and enforce
this.
.SH "STRUCTURED ENTRY CLASSES"
.IX Header "STRUCTURED ENTRY CLASSES"
A \fIstructured entry class\fR defines the behaviour of individual entries
under the regime of a particular database structure.  This is the
\&\fIraison d'e\*^tre\fR for any database structure: the structure class
merely lays out the rules for entries to conform to the structure, but
the structured entry class provides the methods that actually operate on
individual entries.  Because this is completely open-ended, the
requirements of a structured entry class are much less rigid than for a
structure class.  In fact, all of the requirements of a structured entry
class can be met simply by inheriting from
\&\f(CW\*(C`Text::BibTeX::StructuredEntry\*(C'\fR, the other class provided by the
\&\f(CW\*(C`Text::BibTeX::Structure\*(C'\fR module.  (For the record, those requirements
are: a structured entry class must provide the entry
parse/query/manipulate methods of the \f(CW\*(C`Entry\*(C'\fR class, and it must
provide the \f(CW\*(C`check\*(C'\fR, \f(CW\*(C`coerce\*(C'\fR, and \f(CW\*(C`silently_coerce\*(C'\fR methods of the
\&\f(CW\*(C`StructuredEntry\*(C'\fR class.  Since \f(CW\*(C`StructuredEntry\*(C'\fR inherits from
\&\f(CW\*(C`Entry\*(C'\fR, both of these requirements are met \*(L"for free\*(R" by structured
entry classes that inherit from \f(CW\*(C`Text::BibTeX::StructuredEntry\*(C'\fR, so
naturally this is the recommended course of action!)
.PP
There are deliberately no other methods required of structured entry
classes.  A particular application (eg. \f(CW\*(C`btformat\*(C'\fR for bibliography
structures) will require certain methods, but it's up to the application
and the structure module to work out the requirements through
documentation.
.SH "CLASS INTERACTIONS"
.IX Header "CLASS INTERACTIONS"
Imposing a database structure on your entries sets off a chain reaction
of interactions between various classes in the \f(CW\*(C`Text::BibTeX\*(C'\fR library
that should be transparent when all goes well.  It could prove confusing
if things go wrong and you have to go wading through several levels of
application program, core \f(CW\*(C`Text::BibTeX\*(C'\fR classes, and some structure
module.
.PP
The justification for this complicated behaviour is that it allows you
to write programs that will use a particular structured module without
knowing the name of the structure when you write the program.  Thus, the
user can supply a database structure, and ultimately the entry objects
you manipulate will be blessed into a class supplied by the structure
module.  A short example will illustrate this.
.PP
Typically, a \f(CW\*(C`Text::BibTeX\*(C'\fR\-based program is based around a kernel of
code like this:
.PP
.Vb 5
\&   $bibfile = new Text::BibTeX::File "foo.bib";
\&   while ($entry = new Text::BibTeX::Entry $bibfile)
\&   {
\&      # process $entry
\&   }
.Ve
.PP
In this case, nothing fancy is happening behind the scenes: the
\&\f(CW$bibfile\fR object is blessed into the \f(CW\*(C`Text::BibTeX::File\*(C'\fR class, and
\&\f(CW$entry\fR is blessed into \f(CW\*(C`Text::BibTeX::Entry\*(C'\fR.  This is the
conventional behaviour of Perl classes, but it is not the only possible
behaviour.  Let us now suppose that \f(CW$bibfile\fR is expected to conform
to a database structure specified by \f(CW$structure\fR (presumably a
user-supplied value, and thus unknown at compile-time):
.PP
.Vb 6
\&   $bibfile = new Text::BibTeX::File "foo.bib";
\&   $bibfile\->set_structure ($structure);
\&   while ($entry = new Text::BibTeX::Entry $bibfile)
\&   {
\&      # process $entry
\&   }
.Ve
.PP
A lot happens behind the scenes with the call to \f(CW$bibfile\fR's
\&\f(CW\*(C`set_structure\*(C'\fR method.  First, a new structure object is created from
\&\f(CW$structure\fR.  The structure name implies the name of a Perl
module\-\-\-the structure module\-\-\-which is \f(CW\*(C`require\*(C'\fR'd by the
\&\f(CW\*(C`Structure\*(C'\fR constructor.  (The main consequence of this is that any
compile-time errors in your structure module will not be revealed until
a \f(CW\*(C`Text::BibTeX::File::set_structure\*(C'\fR or
\&\f(CW\*(C`Text::BibTeX::Structure::new\*(C'\fR call attempts to load it.)
.PP
Recall that the first responsibility of a structure module is to define
a structure class.  The \*(L"structure object\*(R" created by the
\&\f(CW\*(C`set_structure\*(C'\fR method call is actually an object of this class; this
is the first bit of trickery\-\-\-the structure object (buried behind the
scenes) is blessed into a class whose name is not known until run-time.
.PP
Now, the behaviour of the \f(CW\*(C`Text::BibTeX::Entry::new\*(C'\fR constructor
changes subtly: rather than returning an object blessed into the
\&\f(CW\*(C`Text::BibTeX::Entry\*(C'\fR class as you might expect from the code, the
object is blessed into the structured entry class associated with
\&\f(CW$structure\fR.
.PP
For example, if the value of \f(CW$structure\fR is \f(CW"Foo"\fR, that means the
user has supplied a module implementing the \f(CW\*(C`Foo\*(C'\fR structure.
(Ordinarily, this module would be called \f(CW\*(C`Text::BibTeX::Foo\*(C'\fR\-\-\-but you
can customize this.)  Calling the \f(CW\*(C`set_structure\*(C'\fR method on \f(CW$bibfile\fR
will attempt to create a new structure object via the
\&\f(CW\*(C`Text::BibTeX::Structure\*(C'\fR constructor, which loads the structure module
\&\f(CW\*(C`Text::BibTeX::Foo\*(C'\fR.  Once this module is successfully loaded, the new
object is blessed into its structure class, which will presumably be
called \f(CW\*(C`Text::BibTeX::FooStructure\*(C'\fR (again, this is customizable).  The
new object is supplied with the user's structure options via the
\&\f(CW\*(C`set_options\*(C'\fR method (usually inherited), and then it is asked to
describe the actual entry layout by calling its \f(CW\*(C`describe_entry\*(C'\fR
method.  This, in turn, will usually call the inherited \f(CW\*(C`set_fields\*(C'\fR
method for each entry type in the database structure.  When the
\&\f(CW\*(C`Structure\*(C'\fR constructor is finished, the new structure object is stored
in the \f(CW\*(C`File\*(C'\fR object (remember, we started all this by calling
\&\f(CW\*(C`set_structure\*(C'\fR on a \f(CW\*(C`File\*(C'\fR object) for future reference.
.PP
Then, when a new \f(CW\*(C`Entry\*(C'\fR object is created and parsed from that
particular \f(CW\*(C`File\*(C'\fR object, some more trickery happens.  Trivially, the
structure object stored in the \f(CW\*(C`File\*(C'\fR object is also stored in the
\&\f(CW\*(C`Entry\*(C'\fR object.  (The idea is that entries could belong to a database
structure independently of any file, but usually they will just get the
structure that was assigned to their database file.)  More importantly,
the new \f(CW\*(C`Entry\*(C'\fR object is re-blessed into the structured entry class
supplied by the structure module\-\-\-presumably, in this case,
\&\f(CW\*(C`Text::BibTeX::FooEntry\*(C'\fR (also customizable).
.PP
Once all this sleight-of-hand is accomplished, the application may treat
its entry objects as objects of the structured entry class for the
\&\f(CW\*(C`Foo\*(C'\fR structure\-\-\-they may call the check/coerce methods inherited from
\&\f(CW\*(C`Text::BibTeX::StructuredEntry\*(C'\fR, and they may also call any methods
specific to entries for this particular database structure.  What these
methods might be is up to the structure implementor to decide and
document; thus, applications may be specific to one particular database
structure, or they may work on all structures that supply certain
methods.  The choice is up to the application developer, and the range
of options open to him depends on which methods structure implementors
provide.
.SH "EXAMPLE"
.IX Header "EXAMPLE"
For example code, please refer to the source of the \f(CW\*(C`Bib\*(C'\fR module and
the \f(CW\*(C`btcheck\*(C'\fR, \f(CW\*(C`btsort\*(C'\fR, and \f(CW\*(C`btformat\*(C'\fR applications supplied with
\&\f(CW\*(C`Text::BibTeX\*(C'\fR.
.SH "METHODS 1: BASE STRUCTURE CLASS"
.IX Header "METHODS 1: BASE STRUCTURE CLASS"
The first class provided by the \f(CW\*(C`Text::BibTeX::Structure\*(C'\fR module is
\&\f(CW\*(C`Text::BibTeX::Structure\*(C'\fR.  This class is intended to provide methods
that will be inherited by user-supplied structure classes; such classes
should not override any of the methods described here (except
\&\f(CW\*(C`known_option\*(C'\fR and \f(CW\*(C`default_option\*(C'\fR) without very good reason.
Furthermore, overriding the \f(CW\*(C`new\*(C'\fR method would be useless, because in
general applications won't know the name of your structure class\-\-\-they
can only call \f(CW\*(C`Text::BibTeX::Structure::new\*(C'\fR (usually via
\&\f(CW\*(C`Text::BibTeX::File::set_structure\*(C'\fR).
.PP
Finally, there are three methods that structure classes should
implement: \f(CW\*(C`known_option\*(C'\fR, \f(CW\*(C`default_option\*(C'\fR, and \f(CW\*(C`describe_entry\*(C'\fR.
The first two are described in \*(L"Structure options\*(R" above, the latter
in \*(L"Field lists and constraint sets\*(R".  Note that \f(CW\*(C`describe_entry\*(C'\fR
depends heavily on the \f(CW\*(C`set_fields\*(C'\fR, \f(CW\*(C`add_fields\*(C'\fR, and
\&\f(CW\*(C`add_constraints\*(C'\fR methods described here.
.Sh "Constructor/simple query methods"
.IX Subsection "Constructor/simple query methods"
.IP "new (\s-1STRUCTURE\s0, [\s-1OPTION\s0 => \s-1VALUE\s0, ...])" 4
.IX Item "new (STRUCTURE, [OPTION => VALUE, ...])"
Constructs a new structure object\-\-\-\fInot\fR a \f(CW\*(C`Text::BibTeX::Structure\*(C'\fR
object, but rather an object blessed into the structure class associated
with \s-1STRUCTURE\s0.  More precisely:
.RS 4
.IP "\(bu" 4
Loads (with \f(CW\*(C`require\*(C'\fR) the module implementing \s-1STRUCTURE\s0.  In the
absence of other information, the module name is derived by appending
\&\s-1STRUCTURE\s0 to \f(CW"Text::BibTeX::"\fR\-\-\-thus, the module \f(CW\*(C`Text::BibTeX::Bib\*(C'\fR
implements the \f(CW\*(C`Bib\*(C'\fR structure.  Use the pseudo-option \f(CW\*(C`module\*(C'\fR to
override this module name.  For instance, if the structure \f(CW\*(C`Foo\*(C'\fR is
implemented by the module \f(CW\*(C`Foo\*(C'\fR:
.Sp
.Vb 2
\&   $structure = new Text::BibTeX::Structure
\&      (\*(AqFoo\*(Aq, module => \*(AqFoo\*(Aq);
.Ve
.Sp
This method \f(CW\*(C`die\*(C'\fRs if there are any errors loading/compiling the
structure module.
.IP "\(bu" 4
Verifies that the structure module provides a structure class and a
structured entry class.  The structure class is named by appending
\&\f(CW"Structure"\fR to the name of the module, and the structured entry class
by appending \f(CW"Entry"\fR.  Thus, in the absence of a \f(CW\*(C`module\*(C'\fR option,
these two classes (for the \f(CW\*(C`Bib\*(C'\fR structure) would be named
\&\f(CW\*(C`Text::BibTeX::BibStructure\*(C'\fR and \f(CW\*(C`Text::BibTeX::BibEntry\*(C'\fR.  Either or
both of the default class names may be overridden by having the
structure module return a reference to a hash (as opposed to the
traditional \f(CW1\fR returned by modules).  This hash could then supply a
\&\f(CW\*(C`structure_class\*(C'\fR element to name the structure class, and an
\&\f(CW\*(C`entry_class\*(C'\fR element to name the structured entry class.
.Sp
Apart from ensuring that the two classes actually exist, \f(CW\*(C`new\*(C'\fR verifies
that they inherit correctly (from \f(CW\*(C`Text::BibTeX::Structure\*(C'\fR and
\&\f(CW\*(C`Text::BibTeX::StructuredEntry\*(C'\fR respectively), and that the structure
class provides the required \f(CW\*(C`known_option\*(C'\fR, \f(CW\*(C`default_option\*(C'\fR, and
\&\f(CW\*(C`describe_entry\*(C'\fR methods.
.IP "\(bu" 4
Creates the new structure object, and blesses it into the structure
class.  Supplies it with options by passing all (\s-1OPTION\s0, \s-1VALUE\s0) pairs to
its \f(CW\*(C`set_options\*(C'\fR method.  Calls its \f(CW\*(C`describe_entry\*(C'\fR method, which
should list the field requirements for all entry types recognized by
this structure.  \f(CW\*(C`describe_entry\*(C'\fR will most likely use some or all of
the \f(CW\*(C`set_fields\*(C'\fR, \f(CW\*(C`add_fields\*(C'\fR, and \f(CW\*(C`add_constraints\*(C'\fR
methods\-\-\-described below\-\-\-for this.
.RE
.RS 4
.RE
.IP "name ()" 4
.IX Item "name ()"
Returns the name of the structure described by the object.
.IP "entry_class ()" 4
.IX Item "entry_class ()"
Returns the name of the structured entry class associated with this
structure.
.Sh "Field structure description methods"
.IX Subsection "Field structure description methods"
.IP "add_constraints (\s-1TYPE\s0, \s-1CONSTRAINT\s0, ...)" 4
.IX Item "add_constraints (TYPE, CONSTRAINT, ...)"
Adds one or more field constraints to the structure.  A field constraint
is specified as a reference to a three-element list; the last element is
a reference to the list of fields affected, and the first two elements
are the minimum and maximum number of fields from the constraint set
allowed in an entry of type \s-1TYPE\s0.  See \*(L"Field lists and constraint
sets\*(R" for a full explanation of field constraints.
.IP "add_fields (\s-1TYPE\s0, \s-1REQUIRED\s0 [, \s-1OPTIONAL\s0 [, \s-1CONSTRAINT\s0, ...]])" 4
.IX Item "add_fields (TYPE, REQUIRED [, OPTIONAL [, CONSTRAINT, ...]])"
Adds fields to the required/optional lists for entries of type \s-1TYPE\s0.
Can also add field constraints, but you can just as easily use
\&\f(CW\*(C`add_constraints\*(C'\fR for that.
.Sp
\&\s-1REQUIRED\s0 and \s-1OPTIONAL\s0, if defined, should be references to lists of
fields to add to the respective field lists.  The CONSTRAINTs, if given,
are exactly as described for \f(CW\*(C`add_constraints\*(C'\fR above.
.IP "set_fields (\s-1TYPE\s0, \s-1REQUIRED\s0 [, \s-1OPTIONAL\s0 [, \s-1CONSTRAINTS\s0, ...]])" 4
.IX Item "set_fields (TYPE, REQUIRED [, OPTIONAL [, CONSTRAINTS, ...]])"
Sets the lists of required/optional fields for entries of type \s-1TYPE\s0.
Identical to \f(CW\*(C`add_fields\*(C'\fR, except that the field lists and list of
constraints are set from scratch here, rather than being added to.
.Sh "Field structure query methods"
.IX Subsection "Field structure query methods"
.IP "types ()" 4
.IX Item "types ()"
Returns the list of entry types supported by the structure.
.IP "known_type (\s-1TYPE\s0)" 4
.IX Item "known_type (TYPE)"
Returns true if \s-1TYPE\s0 is a supported entry type.
.IP "known_field (\s-1TYPE\s0, \s-1FIELD\s0)" 4
.IX Item "known_field (TYPE, FIELD)"
Returns true if \s-1FIELD\s0 is in the required list, optional list, or one of
the constraint sets for entries of type \s-1TYPE\s0.
.IP "required_fields (\s-1TYPE\s0)" 4
.IX Item "required_fields (TYPE)"
Returns the list of required fields for entries of type \s-1TYPE\s0.
.IP "optional_fields ()" 4
.IX Item "optional_fields ()"
Returns the list of optional fields for entries of type \s-1TYPE\s0.
.IP "field_constraints ()" 4
.IX Item "field_constraints ()"
Returns the list of field constraints (in the format supplied to
\&\f(CW\*(C`add_constraints\*(C'\fR) for entries of type \s-1TYPE\s0.
.Sh "Option methods"
.IX Subsection "Option methods"
.IP "known_option (\s-1OPTION\s0)" 4
.IX Item "known_option (OPTION)"
Returns false.  This is mainly for the use of derived structures that
don't have any options, and thus don't need to provide their own
\&\f(CW\*(C`known_option\*(C'\fR method.  Structures that actually offer options should
override this method; it should return true if \s-1OPTION\s0 is a supported
option.
.IP "default_option (\s-1OPTION\s0)" 4
.IX Item "default_option (OPTION)"
Crashes with an \*(L"unknown option\*(R" message.  Again, this is mainly for use
by derived structure classes that don't actually offer any options.
Structures that handle options should override this method; every option
handled by \f(CW\*(C`known_option\*(C'\fR should have a default value (which might just
be \f(CW\*(C`undef\*(C'\fR) that is returned by \f(CW\*(C`default_option\*(C'\fR.  Your
\&\f(CW\*(C`default_options\*(C'\fR method should crash on an unknown option, perhaps by
calling \f(CW\*(C`SUPER::default_option\*(C'\fR (in order to ensure consistent error
messages).  For example:
.Sp
.Vb 7
\&   sub default_option
\&   {
\&      my ($self, $option) = @_;
\&      return $default_options{$option}
\&         if exists $default_options{$option};
\&      $self\->SUPER::default_option ($option);   # crash
\&   }
.Ve
.Sp
The default value for an option is returned by \f(CW\*(C`get_options\*(C'\fR when that
options has not been explicitly set with \f(CW\*(C`set_options\*(C'\fR.
.IP "set_options (\s-1OPTION\s0 => \s-1VALUE\s0, ...)" 4
.IX Item "set_options (OPTION => VALUE, ...)"
Sets one or more option values.  (You can supply as many 
\&\f(CW\*(C`OPTION => VALUE\*(C'\fR pairs as you like, just so long as there are an even
number of arguments.)  Each \s-1OPTION\s0 must be handled by the structure
module (as indicated by the \f(CW\*(C`known_option\*(C'\fR method); if not
\&\f(CW\*(C`set_options\*(C'\fR will \f(CW\*(C`croak\*(C'\fR.  Each \s-1VALUE\s0 may be any scalar value; it's
up to the structure module to validate them.
.IP "get_options (\s-1OPTION\s0, ...)" 4
.IX Item "get_options (OPTION, ...)"
Returns the value(s) of one or more options.  Any \s-1OPTION\s0 that has not
been set by \f(CW\*(C`set_options\*(C'\fR will return its default value, fetched using
the \f(CW\*(C`default_value\*(C'\fR method.  If \s-1OPTION\s0 is not supported by the
structure module, then your program either already crashed (when it
tried to set it with \f(CW\*(C`set_option\*(C'\fR), or it will crash here (thanks to
calling \f(CW\*(C`default_option\*(C'\fR).
.SH "METHODS 2: BASE STRUCTURED ENTRY CLASS"
.IX Header "METHODS 2: BASE STRUCTURED ENTRY CLASS"
The other class provided by the \f(CW\*(C`Structure\*(C'\fR module is
\&\f(CW\*(C`StructuredEntry\*(C'\fR, the base class for all structured entry classes.
This class inherits from \f(CW\*(C`Entry\*(C'\fR, so all of its entry
query/manipulation methods are available.  \f(CW\*(C`StructuredEntry\*(C'\fR adds
methods for checking that an entry conforms to the database structure
defined by a structure class.
.PP
It only makes sense for \f(CW\*(C`StructuredEntry\*(C'\fR to be used as a base class;
you would never create standalone \f(CW\*(C`StructuredEntry\*(C'\fR objects.  The
superficial reason for this is that only particular structured-entry
classes have an actual structure class associated with them,
\&\f(CW\*(C`StructuredEntry\*(C'\fR on its own doesn't have any information about allowed
types, required fields, field constraints, and so on.  For a deeper
understanding, consult \*(L"\s-1CLASS\s0 \s-1INTERACTIONS\s0\*(R" above.
.PP
Since \f(CW\*(C`StructuredEntry\*(C'\fR derives from \f(CW\*(C`Entry\*(C'\fR, it naturally operates on
BibTeX entries.  Hence, the following descriptions refer to \*(L"the
entry\*(R"\-\-\-this is just the object (entry) being operated on.  Note that
these methods are presented in bottom-up order, meaning that the methods
you're most likely to actually use\-\-\-\f(CW\*(C`check\*(C'\fR, \f(CW\*(C`coerce\*(C'\fR, and
\&\f(CW\*(C`silently_coerce\*(C'\fR are at the bottom.  On a first reading, you'll
probably want to skip down to them for a quick summary.
.IP "structure ()" 4
.IX Item "structure ()"
Returns the object that defines the structure the entry to which is
supposed to conform.  This will be an instantiation of some structure
class, and exists mainly so the check/coerce methods can query the
structure about the types and fields it recognizes.  If, for some
reason, you wanted to query an entry's structure about the validity of
type \f(CW\*(C`foo\*(C'\fR, you might do this:
.Sp
.Vb 4
\&   # assume $entry is an object of some structured entry class, i.e.
\&   # it inherits from Text::BibTeX::StructuredEntry
\&   $structure = $entry\->structure;
\&   $foo_known = $structure\->known_type (\*(Aqfoo\*(Aq);
.Ve
.IP "check_type ([\s-1WARN\s0])" 4
.IX Item "check_type ([WARN])"
Returns true if the entry has a valid type according to its structure.
If \s-1WARN\s0 is true, then an invalid type results in a warning being
printed.
.IP "check_required_fields ([\s-1WARN\s0 [, \s-1COERCE\s0]])" 4
.IX Item "check_required_fields ([WARN [, COERCE]])"
Checks that all required fields are present in the entry.  If \s-1WARN\s0 is
true, then a warning is printed for every missing field.  If \s-1COERCE\s0 is
true, then missing fields are set to the empty string.
.Sp
This isn't generally used by other code; see the \f(CW\*(C`check\*(C'\fR and \f(CW\*(C`coerce\*(C'\fR
methods below.
.IP "check_field_constraints ([\s-1WARN\s0 [, \s-1COERCE\s0]])" 4
.IX Item "check_field_constraints ([WARN [, COERCE]])"
Checks that the entry conforms to all of the field constraints imposed
by its structure.  Recall that a field constraint consists of a list of
fields, and a minimum and maximum number of those fields that must be
present in an entry.  For each constraint, \f(CW\*(C`check_field_constraints\*(C'\fR
simply counts how many fields in the constraint's field set are present.
If this count falls below the minimum or above the maximum for that
constraint and \s-1WARN\s0 is true, a warning is issued.  In general, this
warning is of the form \*(L"between x and y of fields foo, bar, and baz must
be present\*(R".  The more common cases are handled specially to generate
more useful and human-friendly warning messages.
.Sp
If \s-1COERCE\s0 is true, then the entry is modified to force it into
conformance with all field constraints.  How this is done depends on
whether the violation is a matter of not enough fields present in the
entry, or of too many fields present.  In the former case, just enough
fields are added (as empty strings) to meet the requirements of the
constraint; in the latter case, fields are deleted.  Which fields to add
or delete is controlled by the order of fields in the constraint's field
list.
.Sp
An example should clarify this.  For instance, a field constraint
specifying that exactly one of \f(CW\*(C`author\*(C'\fR or \f(CW\*(C`editor\*(C'\fR must appear in an
entry would look like this:
.Sp
.Vb 1
\&   [1, 1, [\*(Aqauthor\*(Aq, \*(Aqeditor\*(Aq]]
.Ve
.Sp
Suppose the following entry is parsed and expected to conform to this
structure:
.Sp
.Vb 6
\&   @inbook{unknown:1997a,
\&     title = "An Unattributed Book Chapter",
\&     booktitle = "An Unedited Book",
\&     publisher = "Foo, Bar \e& Company",
\&     year = 1997
\&   }
.Ve
.Sp
If \f(CW\*(C`check_field_constraints\*(C'\fR is called on this method with \s-1COERCE\s0 true
(which is done by any of the \f(CW\*(C`full_check\*(C'\fR, \f(CW\*(C`coerce\*(C'\fR, and
\&\f(CW\*(C`silently_coerce\*(C'\fR methods), then the \f(CW\*(C`author\*(C'\fR field is set to the
empty string.  (We go through the list of fields in the constraint's
field set in order \*(-- since \f(CW\*(C`author\*(C'\fR is the first missing field, we
supply it; with that done, the entry now conforms to the
\&\f(CW\*(C`author\*(C'\fR/\f(CW\*(C`editor\*(C'\fR constraint, so we're done.)
.Sp
However, if the same structure was applied to this entry:
.Sp
.Vb 5
\&   @inbook{smith:1997a,
\&     author = "John Smith",
\&     editor = "Fred Jones",
\&     ...
\&   }
.Ve
.Sp
then the \f(CW\*(C`editor\*(C'\fR field would be deleted.  In this case, we allow the
first field in the constraint's field list\-\-\-\f(CW\*(C`author\*(C'\fR.  Since only one
field from the set may be present, all fields after the first one are in
violation, so they are deleted.
.Sp
Again, this method isn't generally used by other code; rather, it is
called by \f(CW\*(C`full_check\*(C'\fR and its friends below.
.IP "full_check ([\s-1WARN\s0 [, \s-1COERCE\s0]])" 4
.IX Item "full_check ([WARN [, COERCE]])"
Returns true if an entry's type and fields are all valid.  That is, it
calls \f(CW\*(C`check_type\*(C'\fR, \f(CW\*(C`check_required_fields\*(C'\fR, and
\&\f(CW\*(C`check_field_constraints\*(C'\fR; if all of them return true, then so does
\&\f(CW\*(C`full_check\*(C'\fR.  \s-1WARN\s0 and \s-1COERCE\s0 are simply passed on to the three
\&\f(CW\*(C`check_*\*(C'\fR methods: the first controls the printing of warnings, and the
second decides whether we should modify the entry to force it into
conformance.
.IP "check ()" 4
.IX Item "check ()"
Checks that the entry conforms to the requirements of its associated
database structure: the type must be known, all required fields must be
present, and all field constraints must be met.  See \f(CW\*(C`check_type\*(C'\fR,
\&\f(CW\*(C`check_required_fields\*(C'\fR, and \f(CW\*(C`check_field_constraints\*(C'\fR for details.
.Sp
Calling \f(CW\*(C`check\*(C'\fR is the same as calling \f(CW\*(C`full_check\*(C'\fR with \s-1WARN\s0 true and
\&\s-1COERCE\s0 false.
.IP "coerce ()" 4
.IX Item "coerce ()"
Same as \f(CW\*(C`check\*(C'\fR, except entries are coerced into conformance with the
database structure\-\-\-that is, it's just like \f(CW\*(C`full_check\*(C'\fR with both
\&\s-1WARN\s0 and \s-1COERCE\s0 true.
.IP "silently_coerce ()" 4
.IX Item "silently_coerce ()"
Same as \f(CW\*(C`coerce\*(C'\fR, except warnings aren't printed\-\-\-that is, it's just
like \f(CW\*(C`full_check\*(C'\fR with \s-1WARN\s0 false and \s-1COERCE\s0 true.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Text::BibTeX, Text::BibTeX::Entry, Text::BibTeX::File
.SH "AUTHOR"
.IX Header "AUTHOR"
Greg Ward <gward@python.net>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 1997\-2000 by Gregory P. Ward.  All rights reserved.  This file
is part of the Text::BibTeX library.  This library is free software; you
may redistribute it and/or modify it under the same terms as Perl itself.
