.\" Automatically generated by Pod::Man 2.16 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "BibTeX::Entry 3"
.TH BibTeX::Entry 3 "2009-10-31" "perl v5.8.7" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Text::BibTeX::Entry \- read and parse BibTeX files
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use Text::BibTeX;            # do not use Text::BibTeX::Entry alone!
\&
\&   # ...assuming that $bibfile and $newbib are both objects of class
\&   # Text::BibTeX::File, opened for reading and writing (respectively):
\&
\&   # Entry creation/parsing methods:
\&   $entry = new Text::BibTeX::Entry;
\&   $entry\->read ($bibfile);
\&   $entry\->parse ($filename, $filehandle);
\&   $entry\->parse_s ($entry_text);
\&
\&   # or:
\&   $entry = new Text::BibTeX::Entry $bibfile;
\&   $entry = new Text::BibTeX::Entry $filename, $filehandle;
\&   $entry = new Text::BibTeX::Entry $entry_text;
\&   
\&   # Entry query methods
\&   warn "error in input" unless $entry\->parse_ok;
\&   $metatype = $entry\->metatype;
\&   $type = $entry\->type;
\&
\&   # if metatype is BTE_REGULAR or BTE_MACRODEF:
\&   $key = $entry\->key;                  # only for BTE_REGULAR metatype
\&   $num_fields = $entry\->num_fields;
\&   @fieldlist = $entry\->fieldlist;
\&   $has_title = $entry\->exists (\*(Aqtitle\*(Aq);
\&   $title = $entry\->get (\*(Aqtitle\*(Aq);
\&   # or:
\&   ($val1,$val2,...$valn) = $entry\->get ($field1, $field2, ..., $fieldn);
\&
\&   # if metatype is BTE_COMMENT or BTE_PREAMBLE:
\&   $value = $entry\->value;
\&
\&   # Author name methods 
\&   @authors = $entry\->split (\*(Aqauthor\*(Aq);
\&   ($first_author) = $entry\->names (\*(Aqauthor\*(Aq);
\&
\&   # Entry modification methods
\&   $entry\->set_type ($new_type);
\&   $entry\->set_key ($new_key);
\&   $entry\->set (\*(Aqtitle\*(Aq, $new_title);
\&   # or:
\&   $entry\->set ($field1, $val1, $field2, $val2, ..., $fieldn, $valn);
\&   $entry\->delete (@fields);
\&   $entry\->set_fieldlist (\e@fieldlist);
\&
\&   # Entry output methods
\&   $entry\->write ($newbib);
\&   $entry\->print ($filehandle);
\&   $entry_text = $entry\->print_s;
\&
\&   # Miscellaneous methods
\&   $entry\->warn ($entry_warning);
\&   # or:
\&   $entry\->warn ($field_warning, $field);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Text::BibTeX::Entry\*(C'\fR does all the real work of reading and parsing
BibTeX files.  (Well, actually it just provides an object-oriented Perl
front-end to a C library that does all that.  But that's not important
right now.)
.PP
BibTeX entries can be read either from \f(CW\*(C`Text::BibTeX::File\*(C'\fR objects (using
the \f(CW\*(C`read\*(C'\fR method), or directly from a filehandle (using the \f(CW\*(C`parse\*(C'\fR
method), or from a string (using \f(CW\*(C`parse_s\*(C'\fR).  The first is preferable,
since you don't have to worry about supplying the filename, and because of
the extra functionality provided by the \f(CW\*(C`Text::BibTeX::File\*(C'\fR class.
Currently, this means that you may specify the \fIdatabase structure\fR to
which entries are expected to conform via the \f(CW\*(C`File\*(C'\fR class.  This lets you
ensure that entries follow the rules for required fields and mutually
constrained fields for a particular type of database, and also gives you
access to all the methods of the \fIstructured entry class\fR for this
database structure.  See Text::BibTeX::Structure for details on database
structures.
.PP
Once you have the entry, you can query it or change it in a variety of
ways.  The query methods are \f(CW\*(C`parse_ok\*(C'\fR, \f(CW\*(C`type\*(C'\fR, \f(CW\*(C`key\*(C'\fR, \f(CW\*(C`num_fields\*(C'\fR,
\&\f(CW\*(C`fieldlist\*(C'\fR, \f(CW\*(C`exists\*(C'\fR, and \f(CW\*(C`get\*(C'\fR.  Methods for changing the entry are
\&\f(CW\*(C`set_type\*(C'\fR, \f(CW\*(C`set_key\*(C'\fR, \f(CW\*(C`set_fieldlist\*(C'\fR, \f(CW\*(C`delete\*(C'\fR, and \f(CW\*(C`set\*(C'\fR.
.PP
Finally, you can output BibTeX entries, again either to an open
\&\f(CW\*(C`Text::BibTeX::File\*(C'\fR object, a filehandle or a string.  (A filehandle or
\&\f(CW\*(C`File\*(C'\fR object must, of course, have been opened in write mode.)  Output to
a \f(CW\*(C`File\*(C'\fR object is done with the \f(CW\*(C`write\*(C'\fR method, to a filehandle via
\&\f(CW\*(C`print\*(C'\fR, and to a string with \f(CW\*(C`print_s\*(C'\fR.  Using the \f(CW\*(C`File\*(C'\fR class is
recommended for future extensibility, although it currently doesn't offer
anything extra.
.SH "METHODS"
.IX Header "METHODS"
.Sh "Entry creation/parsing methods"
.IX Subsection "Entry creation/parsing methods"
.IP "new ([\s-1SOURCE\s0])" 4
.IX Item "new ([SOURCE])"
Creates a new \f(CW\*(C`Text::BibTeX::Entry\*(C'\fR object.  If the \s-1SOURCE\s0 parameter is
supplied, it must be one of the following: a \f(CW\*(C`Text::BibTeX::File\*(C'\fR (or
descendant class) object, a filename/filehandle pair, or a string.  Calls
\&\f(CW\*(C`read\*(C'\fR to read from a \f(CW\*(C`Text::BibTeX::File\*(C'\fR object, \f(CW\*(C`parse\*(C'\fR to read from
a filehandle, and \f(CW\*(C`parse_s\*(C'\fR to read from a string.
.Sp
A filehandle can be specified as a \s-1GLOB\s0 reference, or as an
\&\f(CW\*(C`IO::Handle\*(C'\fR (or descendants) object, or as a \f(CW\*(C`FileHandle\*(C'\fR (or
descendants) object.  (But there's really no point in using
\&\f(CW\*(C`FileHandle\*(C'\fR objects, since \f(CW\*(C`Text::BibTeX\*(C'\fR requires Perl 5.004, which
always includes the \f(CW\*(C`IO\*(C'\fR modules.)  You can \fInot\fR pass in the name of
a filehandle as a string, though, because \f(CW\*(C`Text::BibTeX::Entry\*(C'\fR
conforms to the \f(CW\*(C`use strict\*(C'\fR pragma (which disallows such symbolic
references).
.Sp
The corresponding filename should be supplied in order to allow for
accurate error messages; if you simply don't have the filename, you can
pass \f(CW\*(C`undef\*(C'\fR and you'll get error messages without a filename.  (It's
probably better to rearrange your code so that the filename is
available, though.)
.Sp
Thus, the following are equivalent to read from a file named by
\&\f(CW$filename\fR (error handling ignored):
.Sp
.Vb 3
\&   # good ol\*(Aq fashioned filehandle and GLOB ref
\&   open (BIBFILE, $filename);
\&   $entry = new Text::BibTeX::Entry ($filename, \e*BIBFILE);
\&
\&   # newfangled IO::File thingy
\&   $file = new IO::File $filename;
\&   $entry = new Text::BibTeX::Entry ($filename, $file);
.Ve
.Sp
But using a \f(CW\*(C`Text::BibTeX::File\*(C'\fR object is simpler and preferred:
.Sp
.Vb 2
\&   $file = new Text::BibTeX::File $filename;
\&   $entry = new Text::BibTeX::Entry $file;
.Ve
.Sp
Returns the new object, unless \s-1SOURCE\s0 is supplied and reading/parsing
the entry fails (e.g., due to end of file) \*(-- then it returns false.
.IP "read (\s-1BIBFILE\s0)" 4
.IX Item "read (BIBFILE)"
Reads and parses an entry from \s-1BIBFILE\s0, which must be a
\&\f(CW\*(C`Text::BibTeX::File\*(C'\fR object (or descendant).  The next entry will be read
from the file associated with that object.
.Sp
Returns the same as \f(CW\*(C`parse\*(C'\fR (or \f(CW\*(C`parse_s\*(C'\fR): false if no entry found
(e.g., at end-of-file), true otherwise.  To see if the parse itself failed
(due to errors in the input), call the \f(CW\*(C`parse_ok\*(C'\fR method.
.IP "parse (\s-1FILENAME\s0, \s-1FILEHANDLE\s0)" 4
.IX Item "parse (FILENAME, FILEHANDLE)"
Reads and parses the next entry from \s-1FILEHANDLE\s0.  (That is, it scans the
input until an '@' sign is seen, and then slurps up to the next '@'
sign.  Everything between the two '@' signs [including the first one,
but not the second one \*(-- it's pushed back onto the input stream for the
next entry] is parsed as a BibTeX entry, with the simultaneous
construction of an abstract syntax tree [\s-1AST\s0].  The \s-1AST\s0 is traversed to
ferret out the most interesting information, and this is stuffed into a
Perl hash, which coincidentally is the \f(CW\*(C`Text::BibTeX::Entry\*(C'\fR object
you've been tossing around.  But you don't need to know any of that \*(-- I
just figured if you've read this far, you might want to know something
about the inner workings of this module.)
.Sp
The success of the parse is stored internally so that you can later
query it with the \f(CW\*(C`parse_ok\*(C'\fR method.  Even in the presence of syntax
errors, you'll usually get something resembling your input, but it's
usually not wise to try to do anything with it.  Just call \f(CW\*(C`parse_ok\*(C'\fR,
and if it returns false then silently skip to the next entry.  (The
error messages printed out by the parser should be quite adequate for
the user to figure out what's wrong.  And no, there's currently no way
for you to capture or redirect those error messages \*(-- they're always
printed to \f(CW\*(C`stderr\*(C'\fR by the underlying C code.  That should change in
future releases.)
.Sp
If no '@' signs are seen on the input before reaching end-of-file, then
we've exhausted all the entries in the file, and \f(CW\*(C`parse\*(C'\fR returns a
false value.  Otherwise, it returns a true value \*(-- even if there were
syntax errors.  Hence, it's important to check \f(CW\*(C`parse_ok\*(C'\fR.
.Sp
The \s-1FILENAME\s0 parameter is only used for generating error messages, but
anybody using your program will certainly appreciate your setting it
correctly!
.IP "parse_s (\s-1TEXT\s0)" 4
.IX Item "parse_s (TEXT)"
Parses a BibTeX entry (using the above rules) from the string \s-1TEXT\s0.  The
string is not modified; repeatedly calling \f(CW\*(C`parse_s\*(C'\fR with the same string
will give you the same results each time.  Thus, there's no point in
putting multiple entries in one string.
.Sh "Entry query methods"
.IX Subsection "Entry query methods"
.IP "parse_ok ()" 4
.IX Item "parse_ok ()"
Returns false if there were any serious errors encountered while parsing
the entry.  (A \*(L"serious\*(R" error is a lexical or syntax error; currently,
warnings such as \*(L"undefined macro\*(R" result in an error message being
printed to \f(CW\*(C`stderr\*(C'\fR for the user's edification, but no notice is
available to the calling code.)
.IP "type ()" 4
.IX Item "type ()"
Returns the type of the entry.  (The `type' is the word that follows the
\&'@' sign; e.g. `article', `book', `inproceedings', etc. for the standard
BibTeX styles.)
.IP "metatype ()" 4
.IX Item "metatype ()"
Returns the metatype of the entry.  (The `metatype' is a numeric value used
to classify entry types into four groups: comment, preamble, macro
definition (\f(CW@string\fR entries), and regular (all other entry types).
\&\f(CW\*(C`Text::BibTeX\*(C'\fR exports four constants for these metatypes: \f(CW\*(C`BTE_COMMENT\*(C'\fR,
\&\f(CW\*(C`BTE_PREAMBLE\*(C'\fR, \f(CW\*(C`BTE_MACRODEF\*(C'\fR, and \f(CW\*(C`BTE_REGULAR\*(C'\fR.)
.IP "key ()" 4
.IX Item "key ()"
Returns the key of the entry.  (The key is the token immediately
following the opening `{' or `(' in \*(L"regular\*(R" entries.  Returns \f(CW\*(C`undef\*(C'\fR
for entries that don't have a key, such as macro definition (\f(CW@string\fR)
entries.)
.IP "num_fields ()" 4
.IX Item "num_fields ()"
Returns the number of fields in the entry.  (Note that, currently, this is
\&\fInot\fR equivalent to putting \f(CW\*(C`scalar\*(C'\fR in front of a call to \f(CW\*(C`fieldlist\*(C'\fR.
See below for the consequences of calling \f(CW\*(C`fieldlist\*(C'\fR in a scalar
context.)
.IP "fieldlist ()" 4
.IX Item "fieldlist ()"
Returns the list of fields in the entry.  In a scalar context, returns a
reference to the object's own list of fields.  That way, you can change or
reorder the field list with minimal interference from the class.  I'm not
entirely sure if this is a good idea, so don't rely on it existing in the
future; feel free to play around with it and let me know if you get bitten
in dangerous ways or find this enormously useful.
.IP "exists (\s-1FIELD\s0)" 4
.IX Item "exists (FIELD)"
Returns true if a field named \s-1FIELD\s0 is present in the entry, false
otherwise.
.IP "get (\s-1FIELD\s0, ...)" 4
.IX Item "get (FIELD, ...)"
Returns the value of one or more FIELDs, as a list of values.  For example:
.Sp
.Vb 2
\&   $author = $entry\->get (\*(Aqauthor\*(Aq);
\&   ($author, $editor) = $entry\->get (\*(Aqauthor\*(Aq, \*(Aqeditor\*(Aq);
.Ve
.Sp
If a \s-1FIELD\s0 is not present in the entry, \f(CW\*(C`undef\*(C'\fR will be returned at its
place in the return list.  However, you can't completely trust this as a
test for presence or absence of a field; it is possible for a field to be
present but undefined.  Currently this can only happen due to certain
syntax errors in the input, or if you pass an undefined value to \f(CW\*(C`set\*(C'\fR, or
if you create a new field with \f(CW\*(C`set_fieldlist\*(C'\fR (the new field's value is
implicitly set to \f(CW\*(C`undef\*(C'\fR).
.Sp
Normally, the field value is what the input looks like after \*(L"maximal
processing\*(R"\-\-quote characters are removed, whitespace is collapsed (the
same way that BibTeX itself does it), macros are expanded, and multiple
tokens are pasted together.  (See bt_postprocess for details on the
post-processing performed by \fBbtparse\fR.)
.Sp
For example, if your input file has the following:
.Sp
.Vb 2
\&   @string{of = "of"}
\&   @string{foobars = "Foobars"}
\&
\&   @article{foobar,
\&     title = {   The Mating Habits      } # of # " Adult   " # foobars
\&   }
.Ve
.Sp
then using \f(CW\*(C`get\*(C'\fR to query the value of the \f(CW\*(C`title\*(C'\fR field from the
\&\f(CW\*(C`foobar\*(C'\fR entry would give the string \*(L"The Mating Habits of Adult Foobars\*(R".
.Sp
However, in certain circumstances you may wish to preserve the values as
they appear in the input.  This is done by setting a \f(CW\*(C`preserve_values\*(C'\fR
flag at some point; then, \f(CW\*(C`get\*(C'\fR will return not strings but
\&\f(CW\*(C`Text::BibTeX::Value\*(C'\fR objects.  Each \f(CW\*(C`Value\*(C'\fR object is a list of
\&\f(CW\*(C`Text::BibTeX::SimpleValue\*(C'\fR objects, which in turn consists of a simple
value type (string, macro, or number) and the text of the simple value.
Various ways to set the \f(CW\*(C`preserve_values\*(C'\fR flag and the interface to
both \f(CW\*(C`Value\*(C'\fR and \f(CW\*(C`SimpleValue\*(C'\fR objects are described in
Text::BibTeX::Value.
.IP "value ()" 4
.IX Item "value ()"
Retuns the single string associated with \f(CW@comment\fR and \f(CW@preamble\fR
entries.  For instance, the entry
.Sp
.Vb 2
\&   @preamble{" This is   a preamble" # 
\&             {\-\-\-the concatenation of several strings}}
.Ve
.Sp
would return a value of \*(L"This is a preamble\-\-\-the concatenation of
several strings\*(R".
.Sp
If this entry was parsed in \*(L"value preservation\*(R" mode, then \f(CW\*(C`value\*(C'\fR
acts like \f(CW\*(C`get\*(C'\fR, and returns a \f(CW\*(C`Value\*(C'\fR object rather than a simple
string.
.Sh "Author name methods"
.IX Subsection "Author name methods"
This is the only part of the module that makes any assumption about the
nature of the data, namely that certain fields are lists delimited by a
simple word such as \*(L"and\*(R", and that the delimited sub-strings are human
names of the \*(L"First von Last\*(R" or \*(L"von Last, Jr., First\*(R" style used by
BibTeX.  If you are using this module for anything other than
bibliographic data, you can most likely forget about these two methods.
However, if you are in fact hacking on BibTeX-style bibliographic data,
these could come in very handy \*(-- the name-parsing done by BibTeX is not
trivial, and the list-splitting would also be a pain to implement in
Perl because you have to pay attention to brace-depth.  (Not that it
wasn't a pain to implement in C \*(-- it's just a lot more efficient than a
Perl implementation would be.)
.PP
Incidentally, both of these methods assume that the strings being split
have already been \*(L"collapsed\*(R" in the BibTeX way, i.e. all leading and
trailing whitespace removed and internal whitespace reduced to single
spaces.  This should always be the case when using these two methods on
a \f(CW\*(C`Text::BibTeX::Entry\*(C'\fR object, but these are actually just front ends
to more general functions in \f(CW\*(C`Text::BibTeX\*(C'\fR.  (More general in that you
supply the string to be parsed, rather than supplying the name of an
entry field.)  Should you ever use those more general functions
directly, you might have to worry about collapsing whitespace; see
Text::BibTeX (the \f(CW\*(C`split_list\*(C'\fR and \f(CW\*(C`split_name\*(C'\fR functions in
particular) for more information.
.PP
Please note that the interface to author name parsing is experimental,
subject to change, and open to discussion.  Please let me know if you
have problems with it, think it's just perfect, or whatever.
.IP "split (\s-1FIELD\s0 [, \s-1DELIM\s0 [, \s-1DESC\s0]])" 4
.IX Item "split (FIELD [, DELIM [, DESC]])"
Splits the value of \s-1FIELD\s0 on \s-1DELIM\s0 (default: `and').  Don't assume that
this works the same as Perl's builtin \f(CW\*(C`split\*(C'\fR just because the names are
the same: in particular, \s-1DELIM\s0 must be a simple string (no regexps), and
delimiters that are at the beginning or end of the string, or at non-zero
brace depth, or not surrounded by whitespace, are ignored.  Some examples
might illuminate matters:
.Sp
.Vb 7
\&   if field F is...                then split (F) returns...
\&   \*(AqName1 and Name2\*(Aq               (\*(AqName1\*(Aq, \*(AqName2\*(Aq)
\&   \*(AqName1 and and Name2\*(Aq           (\*(AqName1\*(Aq, undef, \*(AqName2\*(Aq)
\&   \*(AqName1 and\*(Aq                     (\*(AqName1 and\*(Aq)
\&   \*(Aqand Name2\*(Aq                     (\*(Aqand Name2\*(Aq)
\&   \*(AqName1 {and} Name2 and Name3\*(Aq   (\*(AqName1 {and} Name2\*(Aq, \*(AqName3\*(Aq)
\&   \*(Aq{Name1 and Name2} and Name3\*(Aq   (\*(Aq{Name1 and Name2}\*(Aq, \*(AqName3\*(Aq)
.Ve
.Sp
Note that a warning will be issued for empty names (as in the second
example above).  A warning ought to be issued for delimiters at the
beginning or end of a string, but currently this isn't done.  (Hmmm.)
.Sp
\&\s-1DESC\s0 is a one-word description of the substrings; it defaults to 'name'.
It is only used for generating warning messages.
.IP "names (\s-1FIELD\s0)" 4
.IX Item "names (FIELD)"
Splits \s-1FIELD\s0 as described above, and further splits each name into four
components: first, von, last, and jr.
.Sp
Returns a list of \f(CW\*(C`Text::BibTeX::Name\*(C'\fR objects, each of which represents
one name.  Use the \f(CW\*(C`part\*(C'\fR method to query these objects; see
Text::BibTeX::Name for details on the interface to name objects (and on
name-parsing as well).
.Sp
For example if this entry:
.Sp
.Vb 5
\&   @article{foo,
\&            author = {John Smith and 
\&                      Hacker, J. Random and
\&                      Ludwig van Beethoven and
\&                      {Foo, Bar and Company}}}
.Ve
.Sp
has been parsed into a \f(CW\*(C`Text::BibTeX::Entry\*(C'\fR object \f(CW$entry\fR, then
.Sp
.Vb 1
\&   @names = $entry\->names (\*(Aqauthor\*(Aq);
.Ve
.Sp
will put a list of \f(CW\*(C`Text::BibTeX::Name\*(C'\fR objects in \f(CW@names\fR.  These can
be queried individually as described in Text::BibTeX::Name; for instance,
.Sp
.Vb 1
\&   @last = $names[0]\->part (\*(Aqlast\*(Aq);
.Ve
.Sp
would put the list of tokens comprising the last name of the first author
into the \f(CW@last\fR array: \f(CW\*(C`(\*(AqSmith\*(Aq)\*(C'\fR.
.Sh "Entry modification methods"
.IX Subsection "Entry modification methods"
.IP "set_type (\s-1TYPE\s0)" 4
.IX Item "set_type (TYPE)"
Sets the entry's type.
.IP "set_metatype (\s-1METATYPE\s0)" 4
.IX Item "set_metatype (METATYPE)"
Sets the entry's metatype (must be one of the four constants
\&\f(CW\*(C`BTE_COMMENT\*(C'\fR, \f(CW\*(C`BTE_PREAMBLE\*(C'\fR, \f(CW\*(C`BTE_MACRODEF\*(C'\fR, and \f(CW\*(C`BTE_REGULAR\*(C'\fR, which
are all optionally exported from \f(CW\*(C`Text::BibTeX\*(C'\fR).
.IP "set_key (\s-1KEY\s0)" 4
.IX Item "set_key (KEY)"
Sets the entry's key.
.IP "set (\s-1FIELD\s0, \s-1VALUE\s0, ...)" 4
.IX Item "set (FIELD, VALUE, ...)"
Sets the value of field \s-1FIELD\s0.  (\s-1VALUE\s0 might be \f(CW\*(C`undef\*(C'\fR or unsupplied,
in which case \s-1FIELD\s0 will simply be set to \f(CW\*(C`undef\*(C'\fR \*(-- this is where the
difference between the \f(CW\*(C`exists\*(C'\fR method and testing the definedness of
field values becomes clear.)
.Sp
Multiple (\s-1FIELD\s0, \s-1VALUE\s0) pairs may be supplied; they will be processed in
order (i.e. the input is treated like a list, not a hash).  For example:
.Sp
.Vb 2
\&   $entry\->set (\*(Aqauthor\*(Aq, $author);
\&   $entry\->set (\*(Aqauthor\*(Aq, $author, \*(Aqeditor\*(Aq, $editor);
.Ve
.Sp
\&\s-1VALUE\s0 can be either a simple string or a \f(CW\*(C`Text::BibTeX::Value\*(C'\fR object;
it doesn't matter if the entry was parsed in \*(L"full post-processing\*(R" or
\&\*(L"preserve input values\*(R" mode.
.IP "delete (\s-1FIELD\s0)" 4
.IX Item "delete (FIELD)"
Deletes field \s-1FIELD\s0 from an entry.
.IP "set_fieldlist (\s-1FIELDLIST\s0)" 4
.IX Item "set_fieldlist (FIELDLIST)"
Sets the entry's list of fields to \s-1FIELDLIST\s0, which must be a list
reference.  If any of the field names supplied in \s-1FIELDLIST\s0 are not
currently present in the entry, they are created with the value \f(CW\*(C`undef\*(C'\fR
and a warning is printed.  Conversely, if any of the fields currently
present in the entry are not named in the list of fields supplied to
\&\f(CW\*(C`set_fields\*(C'\fR, they are deleted from the entry and another warning is
printed.
.Sh "Entry output methods"
.IX Subsection "Entry output methods"
.IP "write (\s-1BIBFILE\s0)" 4
.IX Item "write (BIBFILE)"
Prints a BibTeX entry on the filehandle associated with \s-1BIBFILE\s0 (which
should be a \f(CW\*(C`Text::BibTeX::File\*(C'\fR object, opened for output).  Currently
the printout is not particularly human-friendly; a highly configurable
pretty-printer will be developed eventually.
.IP "print (\s-1FILEHANDLE\s0)" 4
.IX Item "print (FILEHANDLE)"
Prints a BibTeX entry on \s-1FILEHANDLE\s0.
.IP "print_s ()" 4
.IX Item "print_s ()"
Prints a BibTeX entry to a string, which is the return value.
.Sh "Miscellaneous methods"
.IX Subsection "Miscellaneous methods"
.IP "warn (\s-1WARNING\s0 [, \s-1FIELD\s0])" 4
.IX Item "warn (WARNING [, FIELD])"
Prepends a bit of location information (filename and line number(s)) to
\&\s-1WARNING\s0, appends a newline, and passes it to Perl's \f(CW\*(C`warn\*(C'\fR.  If \s-1FIELD\s0 is
supplied, the line number given is just that of the field; otherwise, the
range of lines for the whole entry is given.  (Well, almost \*(-- currently,
the line number of the last field is used as the last line of the whole
entry.  This is a bug.)
.Sp
For example, if lines 10\-15 of file \fIfoo.bib\fR look like this:
.Sp
.Vb 6
\&   @article{homer97,
\&     author = {Homer Simpson and Ned Flanders},
\&     title = {Territorial Imperatives in Modern Suburbia},
\&     journal = {Journal of Suburban Studies},
\&     year = 1997
\&   }
.Ve
.Sp
then, after parsing this entry to \f(CW$entry\fR, the calls
.Sp
.Vb 2
\&   $entry\->warn (\*(Aqwhat a silly entry\*(Aq);
\&   $entry\->warn (\*(Aqwhat a silly journal\*(Aq, \*(Aqjournal\*(Aq);
.Ve
.Sp
would result in the following warnings being issued:
.Sp
.Vb 2
\&   foo.bib, lines 10\-14: what a silly entry
\&   foo.bib, line 13: what a silly journal
.Ve
.IP "line ([\s-1FIELD\s0])" 4
.IX Item "line ([FIELD])"
Returns the line number of \s-1FIELD\s0.  If the entry was parsed from a string,
this still works\*(--it's just the line number relative to the start of the
string.  If the entry was parsed from a file, this works just as you'd
expect it to: it returns the absolute line number with respect to the
whole file.  Line numbers are one-based.
.Sp
If \s-1FIELD\s0 is not supplied, returns a two-element list containing the line
numbers of the beginning and end of the whole entry.  (Actually, the
\&\*(L"end\*(R" line number is currently inaccurate: it's really the the line
number of the last field in the entry.  But it's better than nothing.)
.IP "filename ()" 4
.IX Item "filename ()"
Returns the name of the file from which the entry was parsed.  Only
works if the file is represented by a \f(CW\*(C`Text::BibTeX::File\*(C'\fR object\-\-\-if
you just passed a filename/filehandle pair to \f(CW\*(C`parse\*(C'\fR, you can't get
the filename back.  (Sorry.)
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Text::BibTeX, Text::BibTeX::File, Text::BibTeX::Structure
.SH "AUTHOR"
.IX Header "AUTHOR"
Greg Ward <gward@python.net>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 1997\-2000 by Gregory P. Ward.  All rights reserved.  This file
is part of the Text::BibTeX library.  This library is free software; you
may redistribute it and/or modify it under the same terms as Perl itself.
