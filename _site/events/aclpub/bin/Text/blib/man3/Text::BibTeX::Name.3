.\" Automatically generated by Pod::Man 2.16 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "BibTeX::Name 3"
.TH BibTeX::Name 3 "2009-10-31" "perl v5.8.7" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Text::BibTeX::Name \- interface to BibTeX\-style author names
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&   $name = new Text::BibTeX::Name;
\&   $name\->split(\*(AqJ. Random Hacker\*(Aq);
\&   # or:
\&   $name = new Text::BibTeX::Name (\*(AqJ. Random Hacker\*(Aq);
\&
\&   @firstname_tokens = $name\->part (\*(Aqfirst\*(Aq);
\&   $lastname = join (\*(Aq \*(Aq, $name\->part (\*(Aqlast\*(Aq));
\&
\&   $format = new Text::BibTeX::NameFormat;
\&   # ...customize $format...
\&   $formatted = $name\->format ($format);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Text::BibTeX::Name\*(C'\fR provides an abstraction for BibTeX-style names and
some basic operations on them.  A name, in the BibTeX world, consists of
a list of \fItokens\fR which are divided amongst four \fIparts\fR: `first',
`von', `last', and `jr'.
.PP
Tokens are separated by whitespace or commas at brace-level zero.  Thus
the name
.PP
.Vb 1
\&   van der Graaf, Horace Q.
.Ve
.PP
has five tokens, whereas the name
.PP
.Vb 1
\&   {Foo, Bar, and Sons}
.Ve
.PP
consists of a single token.  Skip down to \*(L"\s-1EXAMPLES\s0\*(R" for more examples, or
read on if you want to know the exact details of how names are split into
tokens and parts.
.PP
How tokens are divided into parts depends on the form of the name.  If
the name has no commas at brace-level zero (as in the second example),
then it is assumed to be in either \*(L"first last\*(R" or \*(L"first von last\*(R"
form.  If there are no tokens that start with a lower-case letter, then
\&\*(L"first last\*(R" form is assumed: the final token is the last name, and all
other tokens form the first name.  Otherwise, the earliest contiguous
sequence of tokens with initial lower-case letters is taken as the `von'
part; if this sequence includes the final token, then a warning is
printed and the final token is forced to be the `last' part.
.PP
If a name has a single comma, then it is assumed to be in \*(L"von last,
first\*(R" form.  A leading sequence of tokens with initial lower-case
letters, if any, forms the `von' part; tokens between the `von' and the
comma form the `last' part; tokens following the comma form the `first'
part.  Again, if there are no tokens following a leading sequence of
lowercase tokens, a warning is printed and the token immediately
preceding the comma is taken to be the `last' part.
.PP
If a name has more than two commas, a warning is printed and the name is
treated as though only the first two commas were present.
.PP
Finally, if a name has two commas, it is assumed to be in \*(L"von last, jr,
first\*(R" form.  (This is the only way to represent a name with a `jr'
part.)  The parsing of the name is the same as for a one-comma name,
except that tokens between the two commas are taken to be the `jr' part.
.SH "CAVEAT"
.IX Header "CAVEAT"
The C code that does the actual work of splitting up names takes a shortcut
and makes few assumptions about whitespace.  In particular, there must be
no leading whitespace, no trailing whitespace, no consecutive whitespace
characters in the string, and no whitespace characters other than space.
In other words, all whitespace must consist of lone internal spaces.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
The strings \f(CW"John Smith"\fR and \f(CW"Smith, John"\fR are different
representations of the same name, so split into parts and tokens the
same way, namely as:
.PP
.Vb 4
\&   first => (\*(AqJohn\*(Aq)
\&   von   => ()
\&   last  => (\*(AqSmith\*(Aq)
\&   jr    => ()
.Ve
.PP
Note that every part is a list of tokens, even if there is only one
token in that part; empty parts get empty token lists.  Every token is
just a string.  Writing this example in actual code is simple:
.PP
.Vb 5
\&   $name = new Text::BibTeX::Name ("John Smith");  # or "Smith, John"
\&   $name\->part (\*(Aqfirst\*(Aq);       # returns list ("John")
\&   $name\->part (\*(Aqlast\*(Aq);        # returns list ("Smith")
\&   $name\->part (\*(Aqvon\*(Aq);         # returns list ()
\&   $name\->part (\*(Aqjr\*(Aq);          # returns list ()
.Ve
.PP
(We'll omit the empty parts in the rest of the examples: just assume
that any unmentioned part is an empty list.)  If more than two tokens
are included and there's no comma, they'll go to the first name: thus
\&\f(CW"John Q. Smith"\fR splits into
.PP
.Vb 2
\&   first => ("John", "Q."))
\&   last  => ("Smith")
.Ve
.PP
and \f(CW"J. R. R. Tolkein"\fR into
.PP
.Vb 2
\&   first => ("J.", "R.", "R.")
\&   last  => ("Tolkein")
.Ve
.PP
The ambiguous name \f(CW"Kevin Philips Bong"\fR splits into
.PP
.Vb 2
\&   first => ("Kevin", "Philips")
\&   last  => ("Bong")
.Ve
.PP
which may or may not be the right thing, depending on the particular
person.  There's no way to know though, so if this fellow's last name is
\&\*(L"Philips Bong\*(R" and not \*(L"Bong\*(R", the string representation of his name
must disambiguate.  One possibility is \f(CW"Philips Bong, Kevin"\fR which
splits into
.PP
.Vb 2
\&   first => ("Kevin")
\&   last  => ("Philips", "Bong")
.Ve
.PP
Alternately, \f(CW"Kevin {Philips Bong}"\fR takes advantage of the fact that
tokes are only split on whitespace \fIat brace-level zero\fR, and becomes
.PP
.Vb 2
\&   first => ("Kevin")
\&   last  => ("{Philips Bong}")
.Ve
.PP
which is fine if your names are destined to be processed by TeX, but
might be problematic in other contexts.  Similarly, \f(CW"St John\-Mollusc,
Oliver"\fR becomes
.PP
.Vb 2
\&   first => ("Oliver")
\&   last  => ("St", "John\-Mollusc")
.Ve
.PP
which can also be written as \f(CW"Oliver {St John\-Mollusc}"\fR:
.PP
.Vb 2
\&   first => ("Oliver")
\&   last  => ("{St John\-Mollusc}")
.Ve
.PP
Since tokens are separated purely by whitespace, hyphenated names will
work either way: both \f(CW"Nigel Incubator\-Jones"\fR and \f(CW"Incubator\-Jones,
Nigel"\fR come out as
.PP
.Vb 2
\&   first => ("Nigel")
\&   last  => ("Incubator\-Jones")
.Ve
.PP
Multi-token last names with lowercase components \*(-- the \*(L"von part\*(R" \*(--
work fine: both \f(CW"Ludwig van Beethoven"\fR and \f(CW"van Beethoven, Ludwig"\fR
parse (correctly) into
.PP
.Vb 3
\&   first => ("Ludwig")
\&   von   => ("van")
\&   last  => ("Beethoven")
.Ve
.PP
This allows these European aristocratic names to sort properly,
i.e. \fIvan Beethoven\fR under \fIB\fR rather than \fIv\fR.  Speaking of
aristocratic European names, \f(CW"Charles Louis Xavier Joseph de la
Vall{\e\*(Aqe}e Poussin"\fR is handled just fine, and splits into
.PP
.Vb 3
\&   first => ("Charles", "Louis", "Xavier", "Joseph")
\&   von   => ("de", "la")
\&   last  => ("Vall{\e\*(Aqe}e", "Poussin")
.Ve
.PP
so could be sorted under \fIV\fR rather than \fId\fR.  (Note that the sorting
algorithm in Text::BibTeX::BibSort is a slavish imitiation of BibTeX
0.99, and therefore does the wrong thing with these names: the sort key
starts with the \*(L"von\*(R" part.)
.PP
However, capitalized \*(L"von parts\*(R" don't work so well: \f(CW"R. J. Van de
Graaff"\fR splits into
.PP
.Vb 3
\&   first => ("R.", "J.", "Van")
\&   von   => ("de")
\&   last  => ("Graaff")
.Ve
.PP
which is clearly wrong.  This name should be represented as \f(CW"Van de
Graaff, R. J."\fR
.PP
.Vb 2
\&   first => ("R.", "J.")
\&   last  => ("Van", "de", "Graaff")
.Ve
.PP
which is probably right.  (This particular Van de Graaff was an
American, so he probably belongs under \fIV\fR \*(-- which is where my
(British) dictionary puts him.  Other Van de Graaff's mileages may
vary.)
.PP
Finally, many names include a suffix: \*(L"Jr.\*(R", \*(L"\s-1III\s0\*(R", \*(L"fils\*(R", and so
forth.  These are handled, but with some limitations.  If there's a
comma before the suffix (the usual U.S. convention for \*(L"Jr.\*(R"), then the
name should be in \fIlast, jr, first\fR form, e.g. \f(CW"Doe, Jr., John"\fR
comes out (correctly) as
.PP
.Vb 3
\&   first => ("John")
\&   last  => ("Doe")
\&   jr    => ("Jr.")
.Ve
.PP
but \f(CW"John Doe, Jr."\fR is ambiguous and is parsed as
.PP
.Vb 2
\&   first => ("Jr.")
\&   last  => ("John", "Doe")
.Ve
.PP
(so don't do it that way).  If there's no comma before the suffix \*(-- the
usual for Roman numerals, and occasionally seen with \*(L"Jr.\*(R" \*(-- then
you're stuck and have to make the suffix part of the last name.  Thus,
\&\f(CW"Gates III, William H."\fR comes out
.PP
.Vb 2
\&   first => ("William", "H.")
\&   last  => ("Gates", "III")
.Ve
.PP
but \f(CW"William H. Gates III"\fR is ambiguous, and becomes
.PP
.Vb 2
\&   first => ("William", "H.", "Gates")
\&   last  => ("III")
.Ve
.PP
\&\-\- not what you want.  Again, the curly-brace trick comes in handy, so
\&\f(CW"William H. {Gates III}"\fR splits into
.PP
.Vb 2
\&   first => ("William", "H.")
\&   last  => ("{Gates III}")
.Ve
.PP
There is no way to make a comma-less suffix the \f(CW\*(C`jr\*(C'\fR part.  (This is an
unfortunate consequence of slavishly imitating BibTeX 0.99.)
.PP
Finally, names that aren't really names of people but rather are
organization or company names should be forced into a single token by
wrapping them in curly braces.  For example, \*(L"Foo, Bar and Sons\*(R" should
be written \f(CW"{Foo, Bar and Sons}"\fR, which will split as
.PP
.Vb 1
\&   last  => ("{Foo, Bar and Sons}")
.Ve
.PP
Of course, if this is one name in a BibTeX \f(CW\*(C`authors\*(C'\fR or \f(CW\*(C`editors\*(C'\fR
list, this name has to be wrapped in braces anyways (because of the \f(CW"
and "\fR), but that's another story.
.SH "FORMATTING NAMES"
.IX Header "FORMATTING NAMES"
Putting a split-up name back together again in a flexible, customizable
way is the job of another module: see Text::BibTeX::NameFormat.
.SH "METHODS"
.IX Header "METHODS"
.IP "new (\s-1CLASS\s0 [, \s-1NAME\s0 [, \s-1FILENAME\s0, \s-1LINE\s0, \s-1NAME_NUM\s0]])" 4
.IX Item "new (CLASS [, NAME [, FILENAME, LINE, NAME_NUM]])"
Creates a new \f(CW\*(C`Text::BibTeX::Name\*(C'\fR object.  If \s-1NAME\s0 is supplied, it
must be a string containing a single name, and it will be be passed to
the \f(CW\*(C`split\*(C'\fR method for further processing.  \s-1FILENAME\s0, \s-1LINE\s0, and
\&\s-1NAME_NUM\s0, if present, are all also passed to \f(CW\*(C`split\*(C'\fR to allow better
error messages.
.IP "split (\s-1NAME\s0 [, \s-1FILENAME\s0, \s-1LINE\s0, \s-1NAME_NUM\s0])" 4
.IX Item "split (NAME [, FILENAME, LINE, NAME_NUM])"
Splits \s-1NAME\s0 (a string containing a single name) into tokens and
subsequently into the four parts of a BibTeX-style name (first, von,
last, and jr).  (Each part is a list of tokens, and tokens are separated
by whitespace or commas at brace-depth zero.  See above for full details
on how a name is split into its component parts.)
.Sp
The token-lists that make up each part of the name are then stored in
the \f(CW\*(C`Text::BibTeX::Name\*(C'\fR object for later retrieval or formatting with
the \f(CW\*(C`part\*(C'\fR and \f(CW\*(C`format\*(C'\fR methods.
.IP "part (\s-1PARTNAME\s0)" 4
.IX Item "part (PARTNAME)"
Returns the list of tokens in part \s-1PARTNAME\s0 of a name previously split with
\&\f(CW\*(C`split\*(C'\fR.  For example, suppose a \f(CW\*(C`Text::BibTeX::Name\*(C'\fR object is created and
initialized like this:
.Sp
.Vb 2
\&   $name = new Text::BibTeX::Name;
\&   $name\->split (\*(AqCharles Louis Xavier Joseph de la Vall{\e\*(Aqe}e Poussin\*(Aq);
.Ve
.Sp
Then this code:
.Sp
.Vb 1
\&   $name\->part (\*(Aqvon\*(Aq);
.Ve
.Sp
would return the list \f(CW\*(C`(\*(Aqde\*(Aq,\*(Aqla\*(Aq)\*(C'\fR.
.IP "format (\s-1FORMAT\s0)" 4
.IX Item "format (FORMAT)"
Formats a name according to the specifications encoded in \s-1FORMAT\s0, which
should be a \f(CW\*(C`Text::BibTeX::NameFormat\*(C'\fR (or descendant) object.  (In short,
it must supply a method \f(CW\*(C`apply\*(C'\fR which takes a \f(CW\*(C`Text::BibTeX::NameFormat\*(C'\fR
object as its only argument.)  Returns the formatted name as a string.
.Sp
See Text::BibTeX::NameFormat for full details on formatting names.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Text::BibTeX::Entry, Text::BibTeX::NameFormat, bt_split_names.
.SH "AUTHOR"
.IX Header "AUTHOR"
Greg Ward <gward@python.net>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 1997\-2000 by Gregory P. Ward.  All rights reserved.  This file
is part of the Text::BibTeX library.  This library is free software; you
may redistribute it and/or modify it under the same terms as Perl itself.
